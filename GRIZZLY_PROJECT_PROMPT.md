# Grizzly - Data Transformation Mapper Project

## Project Overview

**Name:** Grizzly üêª  
**Purpose:** Visual data transformation mapper that generates Python templates for converting between JSON/XML schemas  
**Key Innovation:** Python-based templates that work both standalone AND in a Java Spring Boot engine

---

## Core Concept

### The Problem We're Solving
- Enterprise systems need to transform data between different schemas (e.g., MISMO mortgage data with 500+ fields)
- Existing solutions are either too verbose (JSON configs) or platform-specific (FreeMarker)
- Need a solution that's:
  - Readable and maintainable
  - Testable locally
  - Production-ready
  - Supports modular organization for large schemas

### The Solution: Grizzly
A visual React UI that generates **dual-mode Python templates**:
1. **Standalone mode**: Run directly with `python transform.py input.json output.json`
2. **Engine mode**: Execute in Java Spring Boot via Jython/GraalVM

---

## Key Design Decisions

### 1. Python Templates (Not JSON DSL)
**Why Python syntax for templates?**
- ‚úÖ 90% less verbose than JSON
- ‚úÖ Natural null handling: `value or default`
- ‚úÖ Easy date/time operations
- ‚úÖ Familiar to developers
- ‚úÖ IDE support (syntax highlighting, autocomplete)
- ‚úÖ Testable standalone
- ‚úÖ Debuggable

**Example comparison:**
```json
// JSON DSL (OLD)
{
  "type": "if",
  "condition": { "field": "loanType", "operator": "equals", "value": "CONVENTIONAL" },
  "then": { "target": "LOAN.PURPOSE", "value": "Purchase" }
}
```

```python
# Python Template (NEW)
if loanType == "CONVENTIONAL":
    LOAN.PURPOSE = "Purchase"
```

### 2. Keep .py Extension (Not .grz)
**Why not custom extension?**
- ‚ùå Can't run standalone: `python file.grz` won't work
- ‚ùå No IDE support
- ‚ùå Can't test without Grizzly UI
- ‚ùå Defeats the "dual-mode" benefit

**Solution:**
- Keep `.py` extension
- Add header: `# GRIZZLY_TEMPLATE_V1` for identification
- Best of both worlds!

### 3. Modular Templates
**For 500+ field schemas:**
```
main module:
  ‚îú‚îÄ customerId ‚Üí direct mapping
  ‚îú‚îÄ personalInfo ‚Üí use personal_info_module
  ‚îú‚îÄ accounts ‚Üí use accounts_module
  ‚îî‚îÄ preferences ‚Üí use preferences_module

personal_info_module:
  ‚îú‚îÄ firstName ‚Üí INPUT.firstName.upper()
  ‚îú‚îÄ lastName ‚Üí INPUT.lastName.upper()
  ‚îî‚îÄ email ‚Üí INPUT.email.lower()

accounts_module:
  ‚îî‚îÄ [50+ account-related field mappings]

preferences_module:
  ‚îî‚îÄ [30+ preference field mappings]
```

**Generated code:**
```python
#!/usr/bin/env python3
# GRIZZLY_TEMPLATE_V1
"""
Generated by Grizzly
"""

from personal_info_mapping import map_personal_info
from accounts_mapping import map_accounts
from preferences_mapping import map_preferences

def transform(INPUT):
    """Main transformation"""
    OUTPUT = {}
    
    OUTPUT["customerId"] = INPUT.customerId
    
    # personalInfo ‚Üí use personal_info module
    map_personal_info(INPUT, OUTPUT)
    
    # accounts ‚Üí use accounts module
    map_accounts(INPUT, OUTPUT)
    
    # preferences ‚Üí use preferences module
    map_preferences(INPUT, OUTPUT)
    
    return OUTPUT

def map_personal_info(INPUT, OUTPUT):
    """personal_info mappings"""
    
    OUTPUT["CUSTOMER"]["FIRST_NAME"] = INPUT.firstName.upper()
    OUTPUT["CUSTOMER"]["LAST_NAME"] = INPUT.lastName.upper()
    OUTPUT["CUSTOMER"]["EMAIL"] = INPUT.email.lower()

# ... other module definitions
```

---

## UI Design (GrizzlyMapper.jsx)

### Inspiration
Based on user's existing FreeMarker mapper UI (uploaded file: freemarker-mapper.jsx)

### Key Features

#### Step 1: Upload Schemas & Template
- **Three upload zones:**
  1. Input Schema (.json)
  2. Output Schema (.json)
  3. Template (.py) - optional, loads existing mappings
- **Visual feedback:**
  - Green checkmark when loaded
  - Shows "X fields" or "Y mappings, Z modules"
  - Alert on successful template load
- **Sample data button** for quick testing

#### Step 2: Mapping Configuration
**Module Tabs:**
- Horizontal tab bar showing all modules
- Active module highlighted
- Shows mapping count per module
- Editable module names (click to rename)
- "+" button to add new modules
- Delete button for non-main modules

**Mapping Table:**
- Expandable rows (click arrow to expand)
- Auto-expands when adding new field
- Columns: Target | Source/Module | Logic Type | Delete
- Click on Target ‚Üí opens sidebar with output fields
- Click on Source ‚Üí opens sidebar with tabs:
  - **Fields tab** - Input schema fields
  - **Modules tab** - Available modules to use

**Key UX Decisions:**
1. ‚úÖ Direct click on fields to select (no extra buttons)
2. ‚úÖ Auto-expand new rows
3. ‚úÖ Modules shown in right sidebar, not dropdowns
4. ‚úÖ If/Else fields are clickable for field/module selection
5. ‚úÖ Module assignment at object level (e.g., assign entire `preferences` object to a module)

**Mapping Types:**
- **Direct**: Simple field-to-field with optional transform (upper, lower, format_ssn, etc.)
- **If/Else**: Conditional logic with clickable then/else values

#### Step 3: Export
- Code preview with syntax highlighting
- Copy button
- Download as transform.py
- Back to edit button

### Right Sidebar (Field/Module Browser)
- **Two tabs** (when modules available):
  - Fields: Browse input/output schema
  - Modules: Select module to use
- **Search bar** for filtering
- **Visual hierarchy** for nested objects
- **Icons**: Folder for objects, Database for fields, Layers for modules

---

## Template Format Specification

### Header
```python
#!/usr/bin/env python3
# GRIZZLY_TEMPLATE_V1
"""
Generated by Grizzly
"""
```

### Imports (auto-generated based on module usage)
```python
from customer_details_mapping import map_customer_details
from address_mapping import map_address
```

### Main Transform Function
```python
def transform(INPUT):
    """Main transformation function"""
    OUTPUT = {}
    
    # Direct mappings
    OUTPUT["customerId"] = INPUT.customerId
    
    # Module calls
    # personalInfo ‚Üí use customer_details module
    map_customer_details(INPUT, OUTPUT)
    
    # Transforms
    OUTPUT["CUSTOMER"]["FIRST_NAME"] = INPUT.customer.firstName.upper()
    
    # Conditionals
    OUTPUT["LOAN"]["PURPOSE"] = "Purchase" if INPUT.loanType == "CONVENTIONAL" else "Refinance"
    
    # Nested paths
    OUTPUT["ADDRESS"]["STREET"]["LINE1"] = INPUT.property.address.street
    
    return OUTPUT
```

### Module Functions
```python
def map_customer_details(INPUT, OUTPUT):
    """customer_details mappings"""
    
    OUTPUT["CUSTOMER"]["FIRST_NAME"] = INPUT.customer.firstName.upper()
    OUTPUT["CUSTOMER"]["LAST_NAME"] = INPUT.customer.lastName.upper()
```

---

## Template Parser Specification

### Purpose
Parse existing `.py` templates to reload mappings into the UI

### What It Parses
1. **Module definitions**: `def transform(INPUT):` and `def map_xxx(INPUT, OUTPUT):`
2. **Module calls**: `map_customer(INPUT, OUTPUT)` with comment `# target ‚Üí use module_name module`
3. **Simple assignments**: `OUTPUT["field"] = INPUT.source.upper()`
4. **Nested assignments**: `OUTPUT["a"]["b"]["c"] = INPUT.source`
5. **Conditionals**: `"val1" if INPUT.field == "value" else "val2"`

### Parser Logic (Pseudo-code)
```javascript
function parseTemplate(pythonCode) {
  const modules = [];
  let currentModule = null;
  
  for each line in pythonCode:
    // Detect module definitions
    if line matches "def transform(INPUT):":
      currentModule = new Module("main")
      modules.push(currentModule)
    
    if line matches "def map_XXX(INPUT, OUTPUT):":
      currentModule = new Module(XXX)
      modules.push(currentModule)
    
    // Parse module calls
    if line matches "map_XXX(INPUT, OUTPUT)":
      look at previous line for "# target ‚Üí use XXX module"
      add module call mapping to currentModule
    
    // Parse assignments
    if line matches 'OUTPUT["field"] = INPUT.source.upper()':
      extract target, source, transform
      add direct mapping to currentModule
    
    // Parse nested
    if line matches 'OUTPUT["a"]["b"] = INPUT.source':
      extract full path, source
      add direct mapping to currentModule
    
    // Parse conditionals
    if line matches '"val1" if INPUT.field == "value" else "val2"':
      extract condition, then, else values
      add conditional mapping to currentModule
  
  return { modules, totalMappings }
}
```

### Visual Feedback After Loading
1. ‚úÖ Green checkmark on Template upload zone
2. ‚úÖ Detail text: "15 mappings, 3 modules"
3. ‚úÖ Alert: "‚úÖ Template loaded successfully! 15 mappings from 3 modules"
4. ‚úÖ All module tabs appear
5. ‚úÖ All mappings populated in table

---

## Built-in Transform Functions (99.99% Coverage)

### String Operations
- `upper()` - UPPERCASE
- `lower()` - lowercase
- `capitalize()` - Capitalize First Letter
- `format_ssn(value, mask=True)` - Format SSN as XXX-XX-#### or ###-##-####
- `format_phone(value)` - Format phone as (###) ###-####
- `format_currency(value)` - Format as $1,234.56

### Date Operations
- `parse_date(value, format="%m/%d/%Y")` - Parse date string
- `format_date(value, format="%Y-%m-%d")` - Format date
- `today()` - Current date
- `date_add(date, days=30)` - Add days
- `date_diff(date1, date2, unit="days")` - Calculate difference

### Null Handling
- `coalesce(val1, val2, val3)` - First non-null value
- `nvl(value, "default")` - Null value replacement

### Type Conversion
- `to_number(value)` - Convert to number
- `to_string(value)` - Convert to string
- `to_boolean(value)` - Convert to boolean

### Validation
- `is_valid_email(email)` - Email validation
- `is_valid_ssn(ssn)` - SSN validation
- `is_valid_phone(phone)` - Phone validation

---

## Java Spring Boot Integration (Future)

### Architecture
```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  React UI (GrizzlyMapper.jsx)      ‚îÇ
‚îÇ  - Visual mapping                   ‚îÇ
‚îÇ  - Generates Python templates       ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                 ‚îÇ
                 ‚ñº transform.py
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  Java Spring Boot Engine            ‚îÇ
‚îÇ  - Jython/GraalVM Python interpreter‚îÇ
‚îÇ  - MongoDB storage for templates    ‚îÇ
‚îÇ  - Hot-reload (no restart needed)   ‚îÇ
‚îÇ  - REST API endpoints               ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### REST API Endpoints (Planned)
```java
POST /api/transform/{templateName}
  - Execute transformation with given template
  
POST /api/templates
  - Upload new template
  
PUT /api/templates/{name}
  - Update template (hot-reload)
  
GET /api/templates
  - List all templates
  
POST /api/templates/{name}/validate
  - Validate template without executing
```

### Engine Features
- ‚úÖ Parse and execute Python templates
- ‚úÖ Provide built-in functions (format_ssn, parse_date, etc.)
- ‚úÖ Sandbox execution (no file I/O, limited imports)
- ‚úÖ Cache parsed templates
- ‚úÖ Hot-reload without restart
- ‚úÖ MongoDB storage

---

## File Structure

```
grizzly/
‚îú‚îÄ‚îÄ ui/
‚îÇ   ‚îî‚îÄ‚îÄ GrizzlyMapper.jsx           # Complete React UI (single file)
‚îÇ
‚îú‚îÄ‚îÄ engine/ (future)
‚îÇ   ‚îú‚îÄ‚îÄ src/main/java/com/grizzly/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ GrizzlyEngine.java      # Main engine
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ PythonExecutor.java     # Jython/GraalVM executor
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ BuiltInFunctions.java   # format_ssn, parse_date, etc.
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ TemplateController.java # REST API
‚îÇ   ‚îî‚îÄ‚îÄ pom.xml
‚îÇ
‚îî‚îÄ‚îÄ examples/
    ‚îú‚îÄ‚îÄ transform.py                 # Example template
    ‚îú‚îÄ‚îÄ input-schema.json
    ‚îî‚îÄ‚îÄ output-schema.json
```

---

## Current State & Next Steps

### ‚úÖ Completed
1. Complete React UI (GrizzlyMapper.jsx)
2. Python template generation
3. Template parser (reload templates)
4. Modular template support
5. Visual feedback for all actions
6. Field/module selection via sidebar
7. Auto-expand new rows
8. Direct click on fields (no extra buttons)

### üîÑ Next Steps (Continue on GitHub Copilot)
1. **Java Spring Boot Engine**
   - Jython/GraalVM integration
   - Built-in function library
   - REST API endpoints
   - MongoDB integration
   - Hot-reload mechanism

2. **Enhanced UI Features**
   - Loop/array mapping support
   - Validation rules
   - Test data preview
   - Undo/redo
   - Save/load projects
   - Export to different formats

3. **Additional Transform Types**
   - Switch/case statements
   - Complex expressions
   - Custom function definitions
   - Lookup tables

4. **XML Schema Support**
   - XML schema parser
   - XPath expressions
   - XML namespace handling

---

## Key Technical Specifications

### React Component State
```javascript
const [inputSchema, setInputSchema] = useState(null);
const [outputSchema, setOutputSchema] = useState(null);
const [modules, setModules] = useState([{ id, name: "main", mappings: [] }]);
const [activeModule, setActiveModule] = useState(0);
const [expandedRow, setExpandedRow] = useState(null);
const [templateLoaded, setTemplateLoaded] = useState(false);
const [sidebarState, setSidebarState] = useState({ 
  isOpen: false, 
  mode: "source", 
  rowIdx: null, 
  field: null 
});
```

### Mapping Object Structure
```javascript
{
  id: "m_1234567_abc",
  target: "CUSTOMER.FIRST_NAME",          // Output field path
  source: "customer.firstName",            // Input field path OR module name
  isModule: false,                         // true if source is a module
  transformation: "direct",                // "direct" | "conditional"
  transform: "upper",                      // Transform function (for direct)
  
  // For conditionals only:
  condField: "loanType",
  condOp: "==",
  condValue: "CONVENTIONAL",
  thenValue: "Purchase",
  elseValue: "Refinance"
}
```

### Module Object Structure
```javascript
{
  id: "m_1234567_xyz",
  name: "customer_details",               // Module name
  mappings: [...]                         // Array of mapping objects
}
```

---

## Important UX Patterns

### Auto-Expand Pattern
```javascript
const addMapping = () => {
  const newMapping = { id: uid(), target: "", source: "", transformation: "direct" };
  const newMappings = [...mappings, newMapping];
  updateModuleMappings(activeModule, newMappings);
  setExpandedRow(newMappings.length - 1);  // ‚Üê Auto-expand!
};
```

### Direct Click Pattern (No Extra Buttons)
```jsx
// Then/Else inputs are directly clickable
<input 
  value={mapping.thenValue || ""} 
  onChange={(e) => onChange({ thenValue: e.target.value })} 
  onClick={() => onOpenSidebar("source", "thenValue")}
  className="cursor-pointer hover:bg-blue-50"
  placeholder="click to select"
/>
```

### Module Selection via Sidebar
```jsx
// Right sidebar has two tabs when modules available
<div className="flex border-b">
  <button onClick={() => setTab("fields")}>Fields</button>
  <button onClick={() => setTab("modules")}>Modules</button>
</div>

{tab === "fields" ? (
  // Show input/output fields
) : (
  // Show available modules
)}
```

---

## Example Use Case: MISMO Mortgage Transformation

### Input: Loan Application JSON (500+ fields)
```json
{
  "applicationId": "LN-2024-001",
  "customer": {
    "firstName": "John",
    "lastName": "Doe",
    "ssn": "123456789",
    "dob": "01/15/1985",
    "income": 120000
  },
  "property": {
    "address": {
      "street": "123 Main St",
      "city": "New York",
      "state": "NY"
    },
    "value": 450000
  },
  "loan": {
    "amount": 350000,
    "type": "CONVENTIONAL",
    "term": 30
  }
  // ... 400+ more fields
}
```

### Output: MISMO 3.4 XML (500+ fields)
```xml
<LOAN>
  <LOAN_IDENTIFIER>LN-2024-001</LOAN_IDENTIFIER>
  <PARTIES>
    <PARTY>
      <NAME>
        <FIRST>JOHN</FIRST>
        <LAST>DOE</LAST>
      </NAME>
      <TAX_ID>123-45-6789</TAX_ID>
    </PARTY>
  </PARTIES>
  <!-- ... 400+ more fields -->
</LOAN>
```

### Grizzly Approach: Modular Templates
1. **Create modules:**
   - customer_module (50 fields)
   - property_module (80 fields)
   - loan_module (60 fields)
   - employment_module (70 fields)
   - financial_module (200 fields)
   - etc.

2. **Main template:**
   - Orchestrates all modules
   - Handles top-level fields
   - Calls module functions

3. **Benefits:**
   - Each module is ~50-100 fields (manageable)
   - Different team members can work on different modules
   - Easy to test modules independently
   - Clean git diffs per module
   - Reusable across projects

---

## Prompt for GitHub Copilot

```
I'm building Grizzly, a data transformation mapper that generates Python templates.

CONTEXT:
- React UI (GrizzlyMapper.jsx) creates visual mappings
- Generates Python .py files (dual-mode: standalone + engine)
- Supports modular templates for 500+ field schemas
- Template parser reloads existing .py files
- Modules shown in right sidebar, assignable to objects

COMPLETED:
‚úÖ Full React UI with all features
‚úÖ Python template generation
‚úÖ Template parser (parses modules, assignments, conditionals)
‚úÖ Module system with tabs
‚úÖ Field/module selection sidebar
‚úÖ Visual feedback on all actions

NEXT: Java Spring Boot Engine
- Use Jython or GraalVM to execute Python templates
- Provide built-in functions (format_ssn, parse_date, etc.)
- REST API for transformation execution
- MongoDB storage for templates
- Hot-reload without restart

The Python templates look like this:
[paste generated code example]

Help me build the Java Spring Boot engine that executes these templates.
```

---

## Contact & Credits

**Developer Journey:** Full conversation documented  
**Key Decisions:** Python templates, .py extension, modular system, direct-click UX  
**Current File:** GrizzlyMapper.jsx (complete working UI)  
**Ready For:** Java Spring Boot engine development

üêª **Grizzly - Bear-ly any configuration needed!**
